#!/bin/bash

set -eu

SCRIPT_DIR=$(cd $(dirname $0) && pwd)
source $SCRIPT_DIR/config
source $SCRIPT_DIR/library.sh

IMAGES_DIR="$BASE_DIR/images"

IMAGE_RAW="$IMAGES_DIR/${NAME}.raw"
IMAGE_QCOW2="$IMAGES_DIR/${NAME}.qcow2"

BTRFS_SEND_DIR="$BASE_DIR/btrfs-send"

PARAMETERS="$@"

MP=$(mktemp -d)
TMP=$(mktemp)
DEV=''
NBD=''

COMPRESS='gz'
SEND_MAIL=0

export PATH=/sbin:/usr/sbin:$PATH

LANG=C

function run()
{
  logger -p kern.debug -- "$@"
  echo "$@"
  $@
}

function epilogue()
{
  rc=$?

  set +eu

  cd $HOME

  rm $TMP

  test "$DEV" && {
    mount | egrep $MP && umount $MP
    losetup -d ${DEV}
  }

  rmdir $MP

  test "$NBD" && {
    mount | egrep ${NBD}p2 && umount ${NBD}p2
    qemu-nbd -d ${NBD}
  }

  if [ $rc -ne 0 ] || [ $SEND_MAIL -ne 0 ]; then
    test -t 0 || mail "$NAME $PARAMETERS ($rc)" < $SCRIPT_DIR/image.out
  fi

  exit $rc
}

function get_nbd()
{
  local size nbd

  modprobe nbd

  (
    cd /sys/devices/virtual/block/
    for nbd in $(ls -d nbd*) ; do
      size=$(cat $nbd/size)
      test $size -eq 0 && break
    done

    echo "/dev/$nbd"
  )
}

function nbd_mount()
{
  NBD=$(get_nbd)
  run qemu-nbd -c ${NBD} $IMAGE_QCOW2
  udevadm settle; sync
  run mount ${NBD}p2 $@
}

function nbd_umount()
{
  run umount $@
  run qemu-nbd -d ${NBD}
  NBD=''
}

function lo_mount()
{
  DEV=$(losetup --partscan --find --show $IMAGE_RAW)
  run mount ${DEV}p2 $@
}

function lo_umount()
{
  run umount $@
  run losetup -d ${DEV}
  DEV=''
}

function remove_()
{
  test -f $IMAGE_RAW && rm $IMAGE_RAW
}

function init_()
{
  test -f $IMAGE_RAW && {
    >&2 echo "The image '$IMAGE_RAW' already exists."
    exit 1
  }

  ##
  # get size
  #
  ssh $SYSTEM 'fdisk -l /dev/sda' > $TMP
  set -- $(grep '^Disk .* bytes, .* sectors' $TMP)
  bytes=$5

  ##
  # create image
  #
  truncate -s $bytes $IMAGE_RAW

  ##
  # install MBR
  #
  # ssh $SYSTEM 'dd if=/dev/sda bs=512 count=2048' > $TMP
  # run dd if=$TMP of=$IMAGE_RAW bs=512 conv=notrunc
  # run sgdisk --clear $IMAGE_RAW > /dev/null 2>&1
  # udevadm settle; sync

  ##
  # clone partition table
  #
  ssh $SYSTEM 'bkup=$(mktemp) && sgdisk --backup=$bkup /dev/sda >/dev/null 2>&1 && cat $bkup' > $TMP
  run sgdisk --load-backup=$TMP $IMAGE_RAW > /dev/null

  # fdisk -l $IMAGE_RAW

  ##
  # create loopback device
  #
  DEV=$(losetup --partscan --find --show $IMAGE_RAW)

  ##
  # clone part 1
  #
  ssh $SYSTEM 'dd if=/dev/sda1 bs=512' > $TMP
  run dd if=$TMP of=${DEV}p1 bs=512

  ##
  # get fsid and label
  #
  ssh $SYSTEM 'btrfs inspect-internal dump-super /dev/sda2' > $TMP
  set -- $(egrep '^fsid[[:blank:]]+' $TMP)
  UUID=$2
  set -- $(egrep '^label[[:blank:]]+' $TMP)
  LABEL=$2

  ##
  # create fs
  #
  run mkfs.btrfs -U $UUID -L $LABEL ${DEV}p2

  ##
  # detach loopback
  #
  run losetup -d ${DEV}
  DEV=''
}

function fullbackup_()
{
  local SNAP=$(date +%Y.%m.%d_%H.%M)

  lo_mount $MP -o compress=zlib:9

  test -d $MP/snapshots || mkdir $MP/snapshots

  ssh $SYSTEM "
    set -eu
    btrfs subvolume snapshot -r / /.btrfs/snapshots/$SNAP >&2
    btrfs send /.btrfs/snapshots/$SNAP | pi$COMPRESS
  " | tee "$BTRFS_SEND_DIR/${SNAP}.full.$COMPRESS" \
  | pi$COMPRESS -d | btrfs receive $MP/snapshots

  lo_umount $MP
}

function backup_()
{
  local PARENT
  local SNAP=$(date +%Y.%m.%d_%H.%M)

  lo_mount $MP -o compress=zlib:9

  cd $MP/snapshots
  for dir in $(ls -d *.*.*?*.*) ; do
    test $(btrfs prop get $dir ro) == 'ro=true' && PARENT=$dir
  done
  cd -

  test -d $MP/snapshots/new || mkdir -p $MP/snapshots/new

  ssh $SYSTEM "
    set -eu
    btrfs subvolume snapshot -r / /.btrfs/snapshots/$SNAP >&2
    btrfs send -p /.btrfs/snapshots/$PARENT /.btrfs/snapshots/$SNAP | pi$COMPRESS
  " | tee "$BTRFS_SEND_DIR/${PARENT}-${SNAP}.diff.$COMPRESS" \
  | pi$COMPRESS -d | btrfs receive $MP/snapshots/new

  ##
  # move snapshot
  #
  run btrfs prop set $MP/snapshots/new/$SNAP ro false
  run mv $MP/snapshots/new/$SNAP $MP/snapshots/$SNAP
  run btrfs prop set $MP/snapshots/$SNAP ro true

  ##
  # reorg
  #
  cp $SCRIPT_DIR/reorg $MP/snapshots/reorg
  run $MP/snapshots/reorg
  run fstrim -v $MP

  lo_umount $MP
}

function checkpoint_()
{
  local PARENT

  lo_mount $MP -o compress=zlib:9

  cd $MP/snapshots
  for dir in $(ls -d *.*.*?*.*) ; do
    test $(btrfs prop get $dir ro) == 'ro=true' && PARENT=$dir
  done

  test "$PARENT" || exit 1

  btrfs send $PARENT | pi$COMPRESS \
  > "$BTRFS_SEND_DIR/${PARENT}.full.$COMPRESS"

  cd $HOME
  lo_umount $MP
}

function mount_raw_()
{
  lo_mount $MP -o compress=zlib:9,subvolid=5
  cd $MP
  bash
  cd $HOME
  lo_umount $MP
}

function mount_qcow2_()
{
  nbd_mount $MP -o compress=zlib:9,subvolid=5
  cd $MP
  bash
  cd $HOME
  nbd_umount $MP
}

function convert_()
{
  local tmp=$(mktemp "${IMAGE_QCOW2}.XXXX")

  run qemu-img convert -O qcow2 $IMAGE_RAW $tmp
  run mv -f $tmp $IMAGE_QCOW2

  nbd_mount $MP -o compress=zlib:9,subvolid=5

  cd $MP

  test -d @ && btrfs sub delete @

  ##
  # create a snapshot of the last shapshot in @
  #
  snap=$(cd snapshots && ls -d *.*.*?*.* | tail -n1)
  btrfs prop set snapshots/$snap ro false
  btrfs sub snap snapshots/$snap @
  btrfs prop set snapshots/$snap ro true

  btrfs subvolume set-default @

  test -d @backup || btrfs sub create @backup

  test -d @swap || {
    btrfs sub create @swap
    chattr +C @swap
    btrfs property set @swap compression none
  }

  cd @

  ##
  # make sure that files in boot are compressed with zlib
  # grub < 2.04 does not understand zstd
  #
  # btrfs filesystem defragment -r -f -czlib boot
  find boot -xdev -type d -exec btrfs prop set '{}' compression zlib ';'

  ##
  # disable swap
  #
  sed -i 's:^\(/swap/.*\):# \1:' etc/fstab

  cd $HOME

  nbd_umount $MP
}

function list_()
{
  cd $IMAGES_DIR
  for file in ${NAME}.{raw,qcow2} ; do
    test -f $file && {
      set -- $(du -sh $file)
      echo "$(ls -lh $file) - $1"
    }
  done
  SEND_MAIL=1
}

(
  flock -n 9 || {
    >&2 echo "$IMAGES_DIR/.lockfile is locked."
    exit 1
  }

  if [ ! -t 0 ]; then 
    exec > $SCRIPT_DIR/image.out 2>&1
  fi

  start "image $PARAMETERS" epilogue

  for cmd in $@; do
    title "$(date) - $cmd"
    ${cmd}_
  done

) 9> $IMAGES_DIR/.lockfile

exit 0
